# 经典算法
1. **计算最大公约数与最小公倍数**
* 两个数: 
假设为x,y. 设它们的最大公约数为a,最小公倍数为b;               l
    * 要点: x\*y=a\*b
        理解为 $\frac{x*y}{a}=b$ x\*y除以某个数可以得到最小公倍数, 这个数是一个公约数就可以消除x\*y中重复的质因数. 我们知道最大公约数就是x,y中所有重复质因数的乘积, 所以显然x*\y/a就是最小公倍数.
    * 下面求最大公约数, 采用辗转相除法(互减法)
        * 原理: 显然: x=m\*a ; y=n\*a ; x-y=(m-n)\*a.  所以我们不断地用较大地数减去较小的数,直到减到最小, 则最小值显然就是a; (推荐画图理解)
        * c代码实现:
        ```c
        \\我们来定义一个函数
        int gcd(int a,int b)//注意保证a>b
        {
            return (b==0?b:gcd(b:a%b));//这里是一个递归.
            //a%b其实就是用a减b, 如果仍大于b, 就接着再不断减b, 直至a-n\*b<b为止的意思. 
        }
        ```
    * 最小公倍数的代码就很显然了:
        ```c 
        int lcm(int a,int b)//a>b
        {
        return (a*b/gcd(a,b)) ; 
        }
        ```
        
* 多个数:
    * 如法炮制 最大公约数: 取(a,b,c,d)
        1. 取几个数中最小的数, 假设为a;
        2. 其余每个数分别与a相减, 得出的数组最大公约数仍未变;
        3. 重复1,2步骤; 
        4. 出现0后,排除0,对其余数继续进行该步骤;
        5. 直至只剩下一个元素非0, 即为最大公约数.
    * 代码:
    ```c
    #define MIN(x,y) (x<y?x:y)//搞个最小值算法的宏定义,方便后面理解.
    int i=1,q=1,a[10000],zero=0;//zero是用来统计数组里出现了几个0
    int min,sign;//这个sign用来标记最后哪个不是0
    int main()  
    {
    while(1)
    {
        scanf("%d",&a[i]);
        i++;//记录输入了几个值来求最大公约数
    } 
    while(1)
    {   zero=0;
        min=100000;//比较最小值需要一个比较大的值;千万别把min赋值为0,否则怎么比较min都是0,因为0小于任何正数.
        for(q=1;q<=i;q++)
        {
            if(a[q]!=0&&a[q]<min) min=a[q];
            if(a[q]==0) zero++;
            if(a[q]!=0) sign=q;
        }
        for(q=1;q<=i;q++)
        {  
            if(a[q]>min)
            a[a]=a[q]-min;
        }
        if(zero==i-1) {printf("%d",a[sign]); break;}
    }
        return 0;
    }
    ```
    * 多个数最小公倍数
        * 先取最前面两个元素，按上述方法求出最大公约数，然后再把这个数和下一个元素求最小公倍数，一直求到结尾位置。
        * 代码: 略

2. **计算某天是星期几**
w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1

公式中的符号含义如下，w：星期；c：世纪-1；y：年（两位数）；m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，比如2003年1月1日要看作2002年的13月1日来计算）；d：日；[ ]代表取整，即只要整数部分。(C是世纪数减一，y是年份后两位，M是月份，d是日数。1月和2月要按上一年的13月和14月来算，这时C和y均按上一年取值。)

算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。
```c
 1 #define _CRT_SECURE_NO_WARNINGS
 2 #include<stdio.h>
 3 #include<stdlib.h>
 4 int main()
 5 {
 6     int y, c, m, d, w, year, month, day;
 7     printf("请输入一个日期：\n");
 8     scanf("%d%d%d", &year, &month, &day);
 9     y = year % 100;//年　如2015 即年是15年
10     c = year / 100;// 年份前两位　如2015即20
11     m = month; d = day;
12     if (m == 1 || m == 2) { //判断月份是否为1或2
13         y--;
14         m += 12;//某年的1、2月要看作上一年的13、14月来计算
15     }
16     w = y + y / 4 + c / 4 - 2 * c + 13 * (m + 1) / 5 + d - 1;//蔡勒公式的公式
17     while (w < 0) w += 7;//确保余数为正
18     w %= 7;
19     printf("输入的日期是星期%d", w);
20     system("pause");
21 }
```


3. **不同进制转换**
4. **枚举排列**
5. **快速幂问题:**
* 对大素数取模:
```cpp
#define MOD 1000000007
typedef long long ll;
ll qpow(ll a, ll n)
{
    if (n == 0)
        return 1;
    else if (n % 2 == 1)
        return qpow(a, n - 1) * a % MOD;
    else
    {
        ll temp = qpow(a, n / 2) % MOD;
        return temp * temp % MOD;
    }
}
```
* 非递归类型:
这里把n当成了二进制处理, 那么每一位相当于a自乘了$a^{2i}$
```cpp
//非递归快速幂
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘
        n >>= 1;       //n往右移一位
    }
    return ans;
}
```
5. **高精度问题:**
> 本质上是模拟我们平时计算用的运算方法, 借用数组将每一位储存起来罢了.
* 高精度乘法:

```c
//如果不想后续计算过程太过非人,可以把输入的a,b倒置放入数组中
int a[],b[],c[];//记得用strlen时给数组补后缀\0
char str[];
len1=strlen(a); len2=strlen(b);
for(i=0;i<len1;i++)
{  
    for(j=0;j<len2;j++)
    {
        c[i+j]=a[i]*b[j];
    }
}
for(i=0;i<len1+len2+m;i++)//m用来确保高位不溢出,处理进位
{
    c[i+1]=c[i]/10;
    c[i]=c[i]%10;
}
i=len1+len2+m-1;//将最高位(len1+len2-1)前导0去掉后，转换成字符存储到积串str中
memset(str,0,sizeof(str));
while(c[i]==0)
i--;//判断何处前导0停止
j=0;
for(;i>=0;i--)
{
    str[j++]=c[i]+'0';//转化为字符型数字;
}
//注意我并没有处理符号.并不困难
```
* 高精度阶乘:

```cpp
 result[0]=1;//累乘器初始化赋值为1
 int digits=1;//存放结果的位数，初始化时位数为1
 for(int i=2;i<=n;i++)//i存放每次阶乘的操作数（1\*2\*3...\*n） 
 {
  int jw=0;//jw存放低位向高位的进位数
  for(int j=0;j<digits;j++)//将result从个位起至第digits位依次乘以i 
  {
   int total=result[j]*i+jw;
   result[j]=total%10;//int result[0]存放运算结果的个位，result[1]存放十位 
   jw=total/10;
   if(j==digits-1&&jw)//当最高位比digits高时,这一步骤保证了循环次数可以动态扩大.
   {
    digits++;
   }
  }
 }
```

6. **连通块问题**
题干描述是找链接在一起的#有多少个, 区域大小为 $A_{m\times n}$. 属于dfs初级问题

```c
#include<iostream>
using namespace std;
int n, m;
int ans;
char grass[110][110];
int vis[110][110];
int nx[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
bool in(int x, int y) {
    return x >= 1 && x <= n && y >= 1 && y <= m;
}
 
void dfs(int x, int y) {
    for (int i = 0; i <= 3; i++) {
	int nowx = x + nx[i][0];
	int nowy = y + nx[i][1];
	if (in(nowx, nowy) && grass[nowx][nowy] == '#' && !vis[nowx][nowy]) {
	    vis[nowx][nowy] = 1;
	    dfs(nowx, nowy);
	}
    }
}
 
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
	    cin >> grass[i][j];
	}
    }
    for (int i = 1; i <= n; i++) {
	for (int j = 1; j <= m; j++) {
	    if (grass[i][j] == '#' && !vis[i][j]) {
		ans++;
		vis[i][j] = 1;//代码这里有点问题
		dfs(i, j);
	    }
	}
    }
    cout << ans;
    return 0;
}
```






























